//Забелязваме, че лилавите и сините цветя винаги могат да се заместят със срещуположния и става нещо като огледално - например (Синьо Жълто Лилаво Синьо) и (Лилаво Жълто Синьо Лилаво)
//Затова ще намерим комбинациите само за синьо с жълто като за синьото няма да имаме ограничения (може да са едно до друго, тъй като можем да го заменим с лилаво)
//А за жълтото ще имаме ограниченията - да няма две последователни жълти и да не са в началото или в края на последователността
//Отговорът умножаваме по две, за да намерим колко са общо, ако имаме и лилави
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

long long countSequences(int N) // смятаме жълтото и само един от другите цветове - тъй като синьо и лилаво се допълват огледално
{    
    
    if(N == 0) 
        return 0;
    if(N == 1 || N == 2)
        return 1;

    
    vector<long long> dp(N - 1, 0); //смятаме къде можем да сложим жълтото бе началото или края - затова масива ни е колко елемента имаме между крайните 
    dp[0] = 1; //0 elementa mejdu krainite - 1 vuzmojnost (каквито са си крайните - тоест 2 сини)
    dp[1] = 2; //1 topka mejdu krainite - 2 vuzmojnosti (или Синьо или Жълто)
    
    for(int i = 2; i <= N-2; i++)
    {
        //за dp[i-1] - поставяне на синьо след тези последователности винаги е валидно
        //за dp[i-2] - за тези комбинации е добавена синя (i-1 на брой) след това добавяме жълта и получаваме комбинациите за добавена жълта топка накрая (i на брой) 
        //тоест все едно добавяме СиняЖълта наведнъж, за да сме сигурни, че жълтата е валидна
        dp[i] = (dp[i - 1] /*за синьо*/ + dp[i - 2] /*за жълто*/) % 1000000007;
    }
    return dp[N-2];
}


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int N;
    cin >> N;
    
    cout << (countSequences(N) * 2) % 1000000007; //умножаваме по 2, за да намерим общо за 3те цвята
    return 0;
}
